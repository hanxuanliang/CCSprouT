# 灵活的切片

切片无疑是 Go 语言中最重要的数据结构，也是最有趣的数据结构，它的英文词汇叫 slice。额，你是不是以为slice这个玩意就是数组的指针而已。

学过 Java 语言的人会比较容易理解切片，因为它的内部结构非常类似于 ArrayList，ArrayList 的内部实现也是一个数组。当数组容量不够需要扩容时，就会换新的数组，还需要将老数组的内容拷贝到新数组。ArrayList 内部有两个非常重要的属性 capacity 和 length。capacity 表示内部数组的总长度，length 表示当前已经使用的数组的长度。length 永远不能超过 capacity。

```go 
type struct slice {
    *p
    len()
    cap()
}
```

上述（粗略比喻，具体还是要看源码）中一个切片变量包含三个域，分别是`底层数组的指针、切片的长度 length 和切片的容量 capacity`。切片支持 append 操作可以将新的内容追加到底层数组，也就是填充上面的灰色格子。如果格子满了，切片就需要扩容，底层的数组就会更换。

形象一点说，切片变量是底层数组的视图，底层数组是卧室，切片变量是卧室的窗户。通过窗户我们可以看见底层数组的一部分或全部。一个卧室可以有多个窗户，不同的窗户能看到卧室的不同部分。

## 切片的创建

最通用的内置 `make`：

```go
package main

import "fmt"

func main() {
	var s1 = make([]int, 5, 8)
	var s2 = make([]int, 8)

	fmt.Println("s1: ", s1)
	fmt.Println("s2: ", s2)
}
----------
s1:  [0 0 0 0 0]
s2:  [0 0 0 0 0 0 0 0]

// 也可以使用这段代码
func main() {
	var s1 = make([]int, 5, 8)
	s2 := make([]int, 8)
	fmt.Println("s1: ", s1)
	fmt.Println("s2: ", s2)
}
// 上述是使用了 类型自动推导，省去类型定义
```

我们看到 `make` 创建切片的时候，参数为 `切片的类型、切片的长度和容量` 。其中第三个参数是可选的，如果不提供第三个参数，那么长度和容量相等，也就是说切片的满容的。切片和普通变量一样，也可以使用类型自动推导，省去类型定义以及 `var` 关键字。

## 切片初始化

使用 make 函数创建的切片内容是「零值切片」，也就是内部数组的元素都是零值。Go 语言还提供了另一个种创建切片的语法，允许我们给它赋初值。使用这种方式创建的切片是满容的。

```go
package main

import "fmt"

func main() {
	var s3 []int = []int{1, 2, 3, 4, 5}
	fmt.Println(s3, len(s3), cap(s3))
}
-----------
[1 2 3 4 5] 5 5
```

 内置函数 `len(), cap()` 在开始的结构体里面就说明了，  用来获得切片的长度和容量属性。

## 空切片

在创建切片时，还有两个非常特殊的情况需要考虑，那就是容量和长度都是零的切片，叫着「空切片」，这个不同于前面说的「零值切片」。

```go
package main

import "fmt"

func main() {
	var s4 []int
	var s5 = []int{}	// 等同于var s5 []int
	var s6 = make([]int, 0)

	fmt.Println(s4, s5, s6)
	fmt.Println(len(s4), len(s5), len(s6))
	fmt.Println(cap(s4), cap(s5), cap(s6))
}
----------
[] [] []
0 0 0
0 0 0
```

上面三种形式创建的切片都是「空切片」，不过在内部结构上这三种形式是有差异的，甚至第一种都不叫「空切片」，而是叫着「 nil 切片」。但是在形式上它们一摸一样，用起来没有区别。所以初级用户可以不必区分「空切片」和「 nil 切片」。

## 切片赋值

切片的赋值是一次浅拷贝操作，拷贝的是切片变量的三个域，你可以将切片变量看成`长度为 3 的 int 型数组`，数组的赋值就是浅拷贝。拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意。